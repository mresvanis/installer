package configimage

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/pkg/errors"
	"sigs.k8s.io/yaml"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/types/imagebased"
)

const (
	imageBasedConfigFilename = "imagebased-config.yaml"
)

// ImageBasedConfig reads the imagebased-config.yaml file.
type ImageBasedConfig struct {
	File     *asset.File
	Config   *imagebased.Config
	Template string
}

var _ asset.WritableAsset = (*ImageBasedConfig)(nil)

// Name returns a human friendly name for the asset.
func (*ImageBasedConfig) Name() string {
	return "Image-based Config ISO configuration"
}

// Dependencies returns all of the dependencies directly needed to generate
// the asset.
func (*ImageBasedConfig) Dependencies() []asset.Asset {
	return []asset.Asset{}
}

// Generate generates the Image-based Config manifest.
func (i *ImageBasedConfig) Generate(dependencies asset.Parents) error {
	imageBasedConfigTemplate := `#
# Note: This is a sample ImageBasedConfig file showing
# which fields are available to aid you in creating your
# own imagebased-config.yaml file.
#
apiVersion: v1beta1
kind: ImageBasedConfig
metadata:
  name: example-imagebased-config
  namespace: cluster0
hostname: change-to-hostname
releaseRegistry: quay.io
# networkConfig contains the network configuration for the host in NMState format.
# See https://nmstate.io/examples.html for examples.
networkConfig:
  interfaces:
    - name: eth0
      type: ethernet
      state: up
      mac-address: 00:00:00:00:00:00
      ipv4:
        enabled: true
        address:
          - ip: 192.168.122.2
            prefix-length: 23
        dhcp: false
`

	i.Template = imageBasedConfigTemplate

	// Set the File field correctly with the generated image-based install config YAML content
	i.File = &asset.File{
		Filename: imageBasedConfigFilename,
		Data:     []byte(i.Template),
	}

	return i.finish()
}

// PersistToFile writes the imagebased-config.yaml file to the assets folder.
func (i *ImageBasedConfig) PersistToFile(directory string) error {
	templatePath := filepath.Join(directory, imageBasedConfigFilename)
	templateByte := []byte(i.Template)

	err := os.WriteFile(templatePath, templateByte, 0o600)
	if err != nil {
		return err
	}

	return nil
}

// Files returns the files generated by the asset.
func (i *ImageBasedConfig) Files() []*asset.File {
	if i.File != nil {
		return []*asset.File{i.File}
	}
	return []*asset.File{}
}

// Load returns the image-based config asset from the disk.
func (i *ImageBasedConfig) Load(f asset.FileFetcher) (bool, error) {
	file, err := f.FetchByName(imageBasedConfigFilename)
	if err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, errors.Wrap(err, fmt.Sprintf("failed to load %s file", imageBasedConfigFilename))
	}
	config := &imagebased.Config{}
	if err := yaml.UnmarshalStrict(file.Data, config); err != nil {
		return false, errors.Wrapf(err, "failed to unmarshal %s", imageBasedConfigFilename)
	}

	i.File, i.Config = file, config
	if err = i.finish(); err != nil {
		return false, err
	}
	return true, nil
}

func (i *ImageBasedConfig) finish() error {
	// TODO: implement
	return nil
}
